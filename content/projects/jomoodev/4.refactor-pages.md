---
title: jomoo.dev 리팩터링-3
description: jomoo.dev 페이지 디렉터리 리팩터링 
date: 2024/01/10
---

# jomoo.dev 리팩터링-3
<div class="flex justify-end text-sm">2024/01/10</div>

### intro
이번 리팩터링은 papes directory 관련 코드들을 리팩터링하려한다.

<img src="/projects/jomoodev/refactor-pages/before_pages.png" width="250" />

현재 pages directory 구조로, detail(programmers, js, jomoodev 등) 항목 당 `[post].vue` 페이지와 `index.vue` 페이지가 있다. category에 따른 detail sideBar와 detail에 따른 작성한 글만 다르고 나머지는 중복되기에 현재 route에 따라 sideBar와 post를 가지고 오는 형식으로 변경하려 한다.

### 리팩터링 후 pages 디렉터리
<img src="/projects/jomoodev/refactor-pages/after_pages.png" width="250" />

nuxt3의 dynamic routes를 이용해 pages 디렉터리를 리팩터링한 구조  
대괄호안에 있는 매개변수 `category`, `detail`, `post` 를 이용해 경로가 동적으로 매핑된다. 예를 들어, 현재 글의 경로가 projects/jomoodev/refactor-pages 일 때 `category`에는 projects가 `detail`에는 jomoodev, `post`에는 refactor-pages가 매개변수로 전달된다.  

dynamic routes를 이용하면 하나의 page 파일에서 동적으로 경로를 결정해, 경로에 따라 데이터를 가지고와 렌더링할 수 있다.

#### `pages/[category]/[detail]/index.vue`
```vue
<script setup>
const route = useRoute();
const { category, detail } = route.params;

const { data: posts } = await useAsyncData(
  `${detail}-posts`,
  () => {
    return queryContent(category, detail).only(['_path', 'description', 'title', 'date']).find();
  },
  {
    transform(posts) {
      return posts.reverse();
    },
  },
);

useHead({
  title: detail,
  meta: [{ name: 'description', content: `${category} ${detail}` }],
});
</script>

<template>
  <NuxtLayout name="side-bar">
    <ContentCard
      v-for="{ _path, description, title, date } in posts"
      :key="title"
      :page-link="_path"
      :description="description"
      :title="title"
      :date="date"
    />
  </NuxtLayout>
</template>

```


리팩터링 후 `index.vue` 페이지  
경로 매개변수 `route.params`의 `category`와 `detail`을 이용해 `queryContent`로 detail 항목의 `posts`를 가지고 오고 있다.   
여기서 변경된 점은 `postStore`를 이용하지 않고, `index.vue`의 setup 단계에서 글을 가지고 온다는 점이다. 이전에는 `app.vue` setup 단계에서 `postStore`에 모든 posts를 가지고 와 저장한 것을 이용했었다.  
하지만 리팩터링을 하다보니, 각 페이지에서 필요한 post를 갖고 오는게 더 좋다고 생각했다. 시작할 때 모든 post를 가지고 오는 것은 작성한 post가 많아 질 수록 앱의 첫 렌더링이 오래걸릴 것이다. 이를 각 페이지에서 필요한 post를 갖고 오도록 분담시키는 것이다.  

nuxt3의 컴포저블 함수 `useAsyncData`를 이용해 post를 가지고 올 때 중복으로 가져오는 것을 방지한다. 서버 측 렌더링에서 비동기 데이터를 가져온 뒤, 클라이언트 측에서 다시 가져오지 않게 해준다.  
`${detail}-posts`를 key로, nuxt에서 데이터 요청에서 중복을 제거할 수 있도록 고유 키를 설정했다. 또한, `useAsyncData` 함수의 매개변수 options에 `transform`을 이용해 가지고 온 post들을 reverse 시켰다.

#### `pages/[category]/[detail]/[post].vue`
```vue
<script setup>
const route = useRoute();
const { detail, post } = route.params;

const { data: surrounds } = await useAsyncData(
  `post-${post}-surrounds`,
  () => {
    return queryContent().only(['_path', 'title', '_dir']).findSurround(route.path);
  },
  {
    transform: (surrounds) => {
      return surrounds.map((surround) => (surround && surround._dir === detail ? surround : null));
    },
  },
);
</script>

<template>
  <NuxtLayout name="side-bar">
    <div class="prose min-w-full md:px-2">
      <ContentDoc />
    </div>
    <div v-if="surrounds?.length" class="flex flex-col md:flex-row w-full gap-2.5 justify-between">
      <div class="md:w-1/3">
        <PostMoveCard
          v-if="surrounds[0]"
          direction="previous"
          :title="surrounds[0].title"
          :path="surrounds[0]._path"
        />
      </div>
      <div class="md:w-1/3">
        <PostMoveCard
          v-if="surrounds[1]"
          direction="next"
          :title="surrounds[1].title"
          :path="surrounds[1]._path"
        />
      </div>
    </div>
  </NuxtLayout>
</template>

```

리팩터링 후 post 페이지

---